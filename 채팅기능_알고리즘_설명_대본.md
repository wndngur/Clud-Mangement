# Club Management 앱 채팅 기능 알고리즘 및 원리 설명서

## 문서 정보
- **버전**: 2.0 (채팅 정지 기능 추가)
- **작성일**: 2025년 12월
- **대상**: 개발자, 평가위원

---

# Part 1: 기술 문서

## 목차
1. [시스템 아키텍처](#1-시스템-아키텍처)
2. [데이터 모델](#2-데이터-모델)
3. [핵심 알고리즘](#3-핵심-알고리즘)
4. [채팅방 유형](#4-채팅방-유형)
5. [채팅 정지 기능](#5-채팅-정지-기능)
6. [주요 클래스](#6-주요-클래스)

---

## 1. 시스템 아키텍처

```
┌─────────────────────────────────────────────────────────────┐
│                      Android App                             │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐  │
│  │ ChatActivity│  │ChatDetail   │  │ ChatListActivity    │  │
│  │ (채팅목록)  │  │Activity     │  │ (친구목록)          │  │
│  │             │  │(채팅화면)   │  │                     │  │
│  └──────┬──────┘  └──────┬──────┘  └──────────┬──────────┘  │
│         │                │                     │             │
│  ┌──────┴────────────────┴─────────────────────┴──────────┐  │
│  │                    FirebaseManager                     │  │
│  │              (싱글톤 패턴 - 중앙 데이터 관리)            │  │
│  └────────────────────────┬───────────────────────────────┘  │
└───────────────────────────┼──────────────────────────────────┘
                            │
                            ▼
┌───────────────────────────────────────────────────────────────┐
│                    Firebase Cloud                              │
├───────────────────────────────────────────────────────────────┤
│  ┌─────────────────┐  ┌─────────────────┐                     │
│  │   Firestore     │  │  Authentication │                     │
│  │   Database      │  │                 │                     │
│  │                 │  │                 │                     │
│  │  - chatRooms    │  │  - User Auth    │                     │
│  │  - messages     │  │  - User ID      │                     │
│  │  - users        │  │                 │                     │
│  └─────────────────┘  └─────────────────┘                     │
└───────────────────────────────────────────────────────────────┘
```

---

## 2. 데이터 모델

### 2.1 Firebase Firestore 구조

```
firestore/
├── chatRooms/                          # 채팅방 컬렉션
│   ├── {chatRoomId}/                   # 개인: "userId1_userId2" / 단체: "group_clubId"
│   │   ├── chatRoomId: string          # 채팅방 ID
│   │   ├── participants: array         # 참여자 userId 배열
│   │   ├── clubId: string              # 관련 동아리 ID
│   │   ├── clubName: string            # 동아리 이름
│   │   ├── lastMessage: string         # 마지막 메시지
│   │   ├── lastMessageTime: timestamp  # 마지막 메시지 시간
│   │   ├── isGroupChat: boolean        # 단체 채팅 여부
│   │   ├── memberCount: number         # 멤버 수 (단체)
│   │   ├── notificationEnabled: bool   # 알림 설정
│   │   ├── leftUserId: string          # 나간 사용자 ID
│   │   ├── allMembersMuted: boolean    # 전체 채팅 정지 ★신규
│   │   ├── mutedMembers: array         # 정지된 멤버 목록 ★신규
│   │   ├── user1: map                  # 사용자1 정보 (개인 채팅)
│   │   ├── user2: map                  # 사용자2 정보 (개인 채팅)
│   │   │
│   │   └── messages/                   # 메시지 서브컬렉션
│   │       └── {messageId}/
│   │           ├── senderId: string
│   │           ├── senderName: string
│   │           ├── message: string
│   │           ├── timestamp: timestamp
│   │           ├── isRead: boolean
│   │           └── edited: boolean
```

### 2.2 Java 모델 클래스

#### ChatRoom.java
```java
public class ChatRoom {
    private String chatRoomId;      // 채팅방 고유 ID
    private String partnerUserId;   // 상대방 ID (개인 채팅)
    private String partnerName;     // 상대방 이름
    private String partnerRole;     // 상대방 직급
    private String clubId;          // 동아리 ID
    private String clubName;        // 동아리 이름
    private String lastMessage;     // 마지막 메시지
    private long lastMessageTime;   // 마지막 메시지 시간
    private int unreadCount;        // 읽지 않은 메시지 수
    private boolean notificationEnabled;  // 알림 활성화
    private String leftUserId;      // 나간 사용자 ID
    private boolean isGroupChat;    // 단체 채팅 여부
    private int memberCount;        // 멤버 수
}
```

#### ChatMessage.java
```java
public class ChatMessage {
    private String messageId;    // 메시지 고유 ID
    private String senderId;     // 발신자 ID
    private String senderName;   // 발신자 이름
    private String message;      // 메시지 내용
    private long timestamp;      // 전송 시간
    private boolean isRead;      // 읽음 여부
}
```

---

## 3. 핵심 알고리즘

### 3.1 채팅방 ID 생성 로직

```java
// 개인 채팅방: 두 사용자 ID를 알파벳순 정렬하여 고유 ID 생성
String chatRoomId;
if (currentUserId.compareTo(partnerUserId) < 0) {
    chatRoomId = currentUserId + "_" + partnerUserId;
} else {
    chatRoomId = partnerUserId + "_" + currentUserId;
}

// 단체 채팅방: "group_" + 동아리ID
String groupChatRoomId = "group_" + clubId;
```

**이유**: 두 사용자 간 채팅방이 중복 생성되지 않도록 일관된 ID 생성

### 3.2 채팅방 생성/조회 알고리즘

```
┌─────────────────────────────────────────────────────────┐
│              createOrGetChatRoom() 알고리즘              │
└─────────────────────────────────────────────────────────┘
                          │
                          ▼
              ┌───────────────────────┐
              │  chatRoomId 생성      │
              │  (두 userId 정렬)     │
              └───────────┬───────────┘
                          │
                          ▼
              ┌───────────────────────┐
              │  Firestore에서 조회   │
              └───────────┬───────────┘
                          │
            ┌─────────────┴─────────────┐
            │                           │
            ▼                           ▼
    ┌───────────────┐           ┌───────────────┐
    │ 존재함        │           │ 존재 안함     │
    │ → 기존 방     │           │ → 새 방 생성  │
    │    반환       │           │               │
    └───────────────┘           └───────────────┘
```

### 3.3 실시간 메시지 수신 (Snapshot Listener)

```java
messageListener = firebaseManager.getDb()
    .collection("chatRooms")
    .document(chatRoomId)
    .collection("messages")
    .addSnapshotListener((queryDocumentSnapshots, e) -> {
        if (e != null || queryDocumentSnapshots == null) return;

        List<ChatMessage> messages = new ArrayList<>();
        for (DocumentSnapshot doc : queryDocumentSnapshots.getDocuments()) {
            ChatMessage message = parseMessage(doc);
            messages.add(message);
        }

        // 클라이언트 측 정렬
        Collections.sort(messages, (m1, m2) ->
            Long.compare(m1.getTimestamp(), m2.getTimestamp()));

        adapter.setMessages(messages);
        scrollToBottom();
    });
```

### 3.4 메시지 전송 알고리즘

```
[전송 버튼 클릭]
      │
      ▼
┌──────────────────┐
│ 1. 입력값 검증   │
│    (빈 메시지?)  │
└──────────────────┘
      │
      ▼
┌──────────────────┐
│ 2. messageData   │
│    객체 생성     │
└──────────────────┘
      │
      ▼
┌──────────────────┐
│ 3. messages      │
│    컬렉션에 추가 │
└──────────────────┘
      │
      ▼
┌──────────────────┐
│ 4. 채팅방 정보   │
│    업데이트      │
│    (lastMessage) │
└──────────────────┘
      │
      ▼
┌──────────────────┐
│ 5. UI 업데이트   │
│    스크롤 이동   │
└──────────────────┘
```

---

## 4. 채팅방 유형

### 4.1 개인 채팅방

| 항목 | 내용 |
|------|------|
| ID 형식 | `{userId1}_{userId2}` (알파벳순 정렬) |
| 참여자 | 2명 |
| 나가기 | 누구나 가능 (단, 슈퍼관리자 상대 시 슈퍼관리자 먼저) |
| 특이사항 | user1, user2 필드에 참여자 정보 저장 |

### 4.2 단체 채팅방

| 항목 | 내용 |
|------|------|
| ID 형식 | `group_{clubId}` |
| 참여자 | 동아리 전체 멤버 |
| 나가기 | 관리자(회장, 부회장, 총무, 회계)만 가능 |
| 특이사항 | 동아리 가입 시 자동 참여 |

---

## 5. 채팅 정지 기능 ★신규

### 5.1 권한 체계

```
┌─────────────────────────────────────────────────────────┐
│                    권한 체계                             │
├─────────────────────────────────────────────────────────┤
│  슈퍼 관리자 (SuperAdmin)                               │
│      └── 모든 권한                                      │
│                                                         │
│  동아리 관리자 (회장, 부회장, 총무, 회계)               │
│      ├── 단체 채팅방 나가기                             │
│      ├── 모든 멤버 채팅 중단 ★                          │
│      └── 개별 멤버 채팅 정지 ★                          │
│                                                         │
│  일반 회원                                              │
│      └── 정지 시 메시지 입력 불가                       │
└─────────────────────────────────────────────────────────┘
```

### 5.2 채팅 정지 알고리즘

```
┌─────────────────────────────────────────────────────────┐
│              채팅 정지 상태 확인 알고리즘                │
└─────────────────────────────────────────────────────────┘
                          │
                          ▼
              ┌───────────────────────┐
              │  listenForMuteStatus()│
              │  실시간 리스너 등록   │
              └───────────┬───────────┘
                          │
                          ▼
              ┌───────────────────────┐
              │  chatRoom 문서 변경   │
              │  감지                 │
              └───────────┬───────────┘
                          │
            ┌─────────────┴─────────────┐
            │                           │
            ▼                           ▼
    ┌───────────────┐           ┌───────────────┐
    │ allMembersMuted│           │ mutedMembers  │
    │ == true?      │           │ contains(me)? │
    └───────┬───────┘           └───────┬───────┘
            │                           │
            └─────────────┬─────────────┘
                          │
                          ▼
              ┌───────────────────────┐
              │  정지 여부 판단       │
              │  (관리자는 제외)      │
              └───────────┬───────────┘
                          │
            ┌─────────────┴─────────────┐
            │                           │
            ▼                           ▼
    ┌───────────────┐           ┌───────────────┐
    │ 정지 상태     │           │ 정상 상태     │
    │ 입력창 숨김   │           │ 입력창 표시   │
    │ 정지 메시지   │           │               │
    └───────────────┘           └───────────────┘
```

### 5.3 Firebase 필드

```javascript
chatRooms/{chatRoomId}: {
    allMembersMuted: boolean,  // 전체 정지
    mutedMembers: ["userId1", "userId2", ...]  // 개별 정지
}
```

---

## 6. 주요 클래스

| 클래스 | 역할 |
|--------|------|
| `ChatActivity` | 채팅방 목록 화면 |
| `ChatDetailActivity` | 채팅 상세 화면, 메시지 송수신 |
| `ChatListActivity` | 친구/멤버 목록 |
| `ChatRoomAdapter` | 채팅방 목록 어댑터 |
| `ChatMessageAdapter` | 메시지 목록 어댑터 |
| `ChatRoom` | 채팅방 데이터 모델 |
| `ChatMessage` | 메시지 데이터 모델 |
| `FirebaseManager` | Firebase 작업 중앙 관리 |

---

# Part 2: 발표 대본

## 발표 개요
- **주제**: 실시간 채팅 시스템의 구현 원리
- **예상 시간**: 5~10분
- **대상**: 교수님 및 평가위원

---

## 1. 도입부 (30초)

> "안녕하세요. 저희 동아리 관리 앱의 핵심 기능 중 하나인 **실시간 채팅 시스템**에 대해 설명드리겠습니다.
>
> 이 채팅 기능은 **카카오톡**과 유사한 사용자 경험을 제공하며, 동아리 회원 간의 원활한 소통을 지원합니다."

---

## 2. 시스템 구조 설명 (1분)

> "먼저 전체적인 시스템 구조를 설명드리겠습니다."

```
┌─────────────┐     실시간 동기화      ┌─────────────────┐
│  사용자 A   │ ◄──────────────────► │                 │
│  (앱)       │                       │    Firebase     │
└─────────────┘                       │   Firestore     │
                                      │   (클라우드DB)  │
┌─────────────┐     실시간 동기화      │                 │
│  사용자 B   │ ◄──────────────────► │                 │
│  (앱)       │                       └─────────────────┘
└─────────────┘
```

> "저희 앱은 **Firebase Firestore**라는 클라우드 데이터베이스를 사용합니다.
>
> Firestore의 가장 큰 특징은 **실시간 동기화** 기능입니다.
>
> 사용자 A가 메시지를 보내면, 서버에 저장됨과 동시에 사용자 B의 화면에도 **즉시** 메시지가 나타납니다.
>
> 이것이 가능한 이유는 Firestore가 **WebSocket** 기반의 지속적인 연결을 유지하기 때문입니다."

---

## 3. 데이터베이스 구조 (1분 30초)

> "다음으로 데이터가 어떻게 저장되는지 설명드리겠습니다."

```
Firestore 데이터베이스
│
├── chatRooms (채팅방 컬렉션)
│   │
│   └── {chatRoomId} (각 채팅방 문서)
│       ├── participants: ["userA_id", "userB_id"]  ← 참여자 목록
│       ├── lastMessage: "안녕하세요"               ← 마지막 메시지
│       ├── lastMessageTime: 1699084800000         ← 마지막 메시지 시간
│       │
│       └── messages (메시지 서브컬렉션)
│           ├── {messageId_1}
│           │   ├── senderId: "userA_id"
│           │   ├── senderName: "김철수"
│           │   ├── message: "안녕하세요"
│           │   └── timestamp: 1699084800000
│           │
│           └── {messageId_2}
│               ├── senderId: "userB_id"
│               ├── senderName: "이영희"
│               ├── message: "네, 안녕하세요!"
│               └── timestamp: 1699084860000
```

> "데이터 구조는 크게 두 가지입니다.
>
> 첫째, **chatRooms 컬렉션**에는 채팅방 정보가 저장됩니다.
> 여기에는 참여자 목록, 마지막 메시지, 시간 정보가 들어갑니다.
>
> 둘째, 각 채팅방 안에는 **messages 서브컬렉션**이 있어서 실제 대화 내용이 저장됩니다.
>
> 이렇게 **계층 구조**로 설계한 이유는 데이터 조회 효율성 때문입니다.
> 채팅방 목록을 불러올 때는 상위 문서만, 대화 내용이 필요할 때만 하위 컬렉션을 조회합니다."

---

## 4. 핵심 알고리즘 설명 (2분)

### 4-1. 채팅방 생성/찾기 알고리즘

> "사용자가 다른 사람과 채팅을 시작할 때의 과정을 설명드리겠습니다."

```
[채팅 시작 버튼 클릭]
         │
         ▼
┌─────────────────────────────┐
│ 기존 채팅방이 있는지 검색   │
│ (두 사용자가 모두 포함된)   │
└─────────────────────────────┘
         │
    ┌────┴────┐
    ▼         ▼
 [있음]     [없음]
    │         │
    ▼         ▼
기존 방    새 채팅방
열기       생성 후 열기
```

> "먼저 두 사용자가 이미 대화한 적이 있는지 확인합니다.
>
> 이를 위해 **arrayContains** 쿼리를 사용합니다.
> 참여자 배열에 현재 사용자와 상대방이 모두 포함된 채팅방을 찾습니다.
>
> 기존 채팅방이 있으면 그 방을 열고, 없으면 새로 생성합니다.
>
> 이 로직 덕분에 **중복 채팅방이 생기지 않습니다**."

### 4-2. 실시간 메시지 수신 알고리즘

> "이제 실시간으로 메시지를 받는 원리를 설명드리겠습니다."

```java
// 핵심 코드 (간략화)
firestore.collection("chatRooms")
    .document(chatRoomId)
    .collection("messages")
    .orderBy("timestamp")
    .addSnapshotListener((snapshots, error) -> {
        // 데이터가 변경될 때마다 이 부분이 자동 실행됨
        for (Document doc : snapshots) {
            // 새 메시지를 화면에 표시
        }
    });
```

> "핵심은 **addSnapshotListener** 메서드입니다.
>
> 일반적인 데이터 조회는 한 번 요청하면 한 번 응답받고 끝납니다.
>
> 하지만 **스냅샷 리스너**는 다릅니다.
> 한 번 등록하면 해당 데이터에 변화가 생길 때마다 **자동으로 콜백 함수가 호출**됩니다.
>
> 상대방이 메시지를 보내서 서버 데이터가 바뀌면,
> 제 앱의 리스너가 이를 감지하고 즉시 화면을 업데이트합니다.
>
> 이것이 **실시간 채팅의 핵심 원리**입니다."

---

## 5. 메시지 전송 과정 (1분)

> "메시지를 보낼 때의 전체 흐름을 설명드리겠습니다."

```
[전송 버튼 클릭]
      │
      ▼
┌──────────────────┐
│ 메시지 데이터    │
│ 객체 생성        │
│ - senderId       │
│ - senderName     │
│ - message        │
│ - timestamp      │
└──────────────────┘
      │
      ▼
┌──────────────────┐
│ Firestore에      │
│ 메시지 저장      │
└──────────────────┘
      │
      ▼
┌──────────────────┐
│ 채팅방 정보      │
│ 업데이트         │
│ - lastMessage    │
│ - lastMessageTime│
└──────────────────┘
      │
      ▼
┌──────────────────┐
│ 상대방 리스너가  │
│ 자동으로 감지    │
│ → 화면 업데이트  │
└──────────────────┘
```

> "사용자가 전송 버튼을 누르면:
>
> 1. 먼저 메시지 데이터 객체를 만듭니다. 보낸 사람 ID, 이름, 내용, 시간을 담습니다.
>
> 2. 이 데이터를 Firestore의 messages 컬렉션에 저장합니다.
>
> 3. 동시에 채팅방 문서의 마지막 메시지 정보도 업데이트합니다.
>    이건 채팅 목록에서 미리보기를 보여주기 위함입니다.
>
> 4. 서버에 데이터가 저장되면, 상대방의 스냅샷 리스너가 이를 감지하고
>    자동으로 화면에 새 메시지를 표시합니다."

---

## 6. 알림 시스템 (1분)

> "마지막으로 알림 기능에 대해 설명드리겠습니다."

```
┌─────────────────────────────────────────┐
│         ChatNotificationManager         │
│  (싱글톤 패턴으로 앱 전체에서 하나만)   │
├─────────────────────────────────────────┤
│                                         │
│  ┌─────────────────┐                    │
│  │ 채팅방 리스너들 │ ← 각 채팅방 감시   │
│  └─────────────────┘                    │
│           │                             │
│           ▼                             │
│  ┌─────────────────┐                    │
│  │ 새 메시지 감지  │                    │
│  └─────────────────┘                    │
│           │                             │
│     ┌─────┴─────┐                       │
│     ▼           ▼                       │
│  [현재 열린   [다른 화면]               │
│   채팅방]         │                     │
│     │             ▼                     │
│  알림 X      알림 표시 + 뱃지 증가      │
│                                         │
└─────────────────────────────────────────┘
```

> "**ChatNotificationManager**라는 클래스가 알림을 관리합니다.
>
> 이 클래스는 **싱글톤 패턴**으로 구현되어, 앱 전체에서 하나의 인스턴스만 존재합니다.
>
> 동작 방식은:
> 1. 사용자의 모든 채팅방에 리스너를 등록합니다.
> 2. 새 메시지가 오면 현재 화면을 확인합니다.
> 3. 해당 채팅방을 보고 있으면 알림을 보내지 않습니다.
> 4. 다른 화면에 있으면 **푸시 알림**을 표시하고,
>    네비게이션 바의 채팅 아이콘에 **뱃지 숫자**를 증가시킵니다.
>
> 이렇게 해서 사용자가 어디에 있든 새 메시지를 놓치지 않도록 했습니다."

---

## 7. 마무리 (30초)

> "정리하면, 저희 채팅 시스템의 핵심 기술은:
>
> 1. **Firebase Firestore**의 실시간 데이터베이스
> 2. **스냅샷 리스너**를 통한 실시간 동기화
> 3. **싱글톤 패턴**의 알림 관리자
>
> 이 세 가지입니다.
>
> 이를 통해 카카오톡과 같은 즉각적인 메시지 전달 경험을 구현했습니다.
>
> 감사합니다. 질문 있으시면 말씀해 주세요."

---

## 예상 질문 및 답변

### Q1. "왜 Firebase를 선택했나요?"

> "Firebase는 Google에서 제공하는 서비스로, 실시간 동기화 기능이 내장되어 있습니다.
> 직접 서버를 구축하면 WebSocket 설정, 서버 관리, 확장성 등을 모두 처리해야 하지만,
> Firebase를 사용하면 이런 복잡한 부분을 신경 쓰지 않고 앱 개발에 집중할 수 있습니다."

### Q2. "동시에 많은 사용자가 접속하면 어떻게 되나요?"

> "Firebase는 자동으로 확장되는 클라우드 인프라를 사용합니다.
> 사용자가 늘어나도 Google의 서버가 자동으로 처리량을 늘려주기 때문에
> 별도의 서버 확장 작업 없이 대응할 수 있습니다."

### Q3. "메시지 순서가 뒤섞이지 않나요?"

> "각 메시지에 **timestamp**라는 시간 정보를 저장합니다.
> 메시지를 불러올 때 이 timestamp를 기준으로 정렬하기 때문에
> 항상 올바른 순서로 메시지가 표시됩니다."

### Q4. "인터넷이 끊기면 어떻게 되나요?"

> "Firestore는 **오프라인 지원** 기능이 있습니다.
> 인터넷이 끊겨도 로컬 캐시에서 데이터를 보여주고,
> 연결이 복구되면 자동으로 동기화됩니다."

### Q5. "보안은 어떻게 처리하나요?"

> "Firebase는 **인증된 사용자**만 데이터에 접근할 수 있도록 보안 규칙을 설정할 수 있습니다.
> 저희 앱에서는 채팅방 참여자만 해당 메시지를 읽고 쓸 수 있도록 규칙을 적용했습니다."

---

## 발표 팁

1. **천천히 말하기**: 기술 용어가 많으므로 청중이 이해할 시간을 주세요.

2. **그림 활용하기**: 위의 다이어그램을 화이트보드나 PPT에 그리면서 설명하면 효과적입니다.

3. **비유 사용하기**:
   - 스냅샷 리스너 = "데이터 변화를 감시하는 CCTV"
   - 싱글톤 = "앱 전체에서 하나뿐인 관리자"

4. **핵심 강조하기**: "실시간 동기화"와 "스냅샷 리스너"가 가장 중요한 개념임을 강조하세요.

5. **자신감 있게**: 코드를 직접 작성했으므로 질문에 자신있게 답변하세요!
