# 🎯 Firebase 기반 대학 동아리 관리 앱 - 핵심 알고리즘

> **프로젝트명**: Club Management System
> **개발 언어**: Java (Android)
> **백엔드**: Firebase (Firestore, Authentication, Storage)
> **작성일**: 2025년 12월

---

## 📑 목차

1. [알고리즘 1: 가중치 기반 동아리 추천 점수 계산](#알고리즘-1-가중치-기반-동아리-추천-점수-계산)
2. [알고리즘 2: 버블 정렬 (추천 점수 기준)](#알고리즘-2-버블-정렬-추천-점수-기준)
3. [알고리즘 3: 상대 시간 표시](#알고리즘-3-상대-시간-표시)
4. [알고리즘 4: 스마트 날짜 표시](#알고리즘-4-스마트-날짜-표시)
5. [알고리즘 5: 중앙동아리 자격 계산](#알고리즘-5-중앙동아리-자격-계산)
6. [알고리즘 6: 가입 신청 기간 체크](#알고리즘-6-가입-신청-기간-체크)
7. [알고리즘 7: 예산 잔액 계산 및 배치 트랜잭션](#알고리즘-7-예산-잔액-계산-및-배치-트랜잭션)
8. [알고리즘 8: 생일 회원 조회 및 정렬](#알고리즘-8-생일-회원-조회-및-정렬)

---

## 알고리즘 1: 가중치 기반 동아리 추천 점수 계산

### 📌 개요

사용자가 선택한 조건(기독교, 분위기, 활동 유형, 목적)과 동아리 정보를 비교하여 **가중치 기반 매칭 점수**를 계산합니다.

### 📊 가중치 체계

| 항목 | 가중치 | 비고 |
|------|--------|------|
| 기독교 동아리 매칭 | 30점 | 가장 높은 가중치 |
| 분위기 매칭 | 20점 | 활기찬/조용한 |
| 활동 유형 매칭 | 각 15점 | 최대 2개 선택 가능 (최대 30점) |
| 목적 매칭 | 각 15점 | 최대 2개 선택 가능 (최대 30점) |
| **최대 점수** | **110점** | - |

### 🔍 알고리즘 설명

```
1. score = 0으로 초기화
2. 기독교 동아리 매칭 검사
   - 사용자가 기독교 원함 AND 동아리가 기독교 → score += 30
3. 분위기 매칭 검사
   - 원하는 분위기 == 동아리 분위기 → score += 20
4. 활동 유형 매칭 검사 (반복문)
   - FOR EACH 선택한 활동 유형:
       IF 동아리 활동 유형에 포함 → score += 15
5. 목적 매칭 검사 (반복문)
   - FOR EACH 선택한 목적:
       IF 동아리 목적에 포함 → score += 15
6. 최종 점수 반환
```

### 💻 의사코드

```java
function calculateRecommendScore(wantChristian, wantAtmosphere,
                                  wantActivityTypes, wantPurposes):
    score = 0

    // Step 1: 기독교 동아리 매칭 (가중치 30)
    if wantChristian AND isChristian:
        score += 30

    // Step 2: 분위기 매칭 (가중치 20)
    if wantAtmosphere != null AND wantAtmosphere == atmosphere:
        score += 20

    // Step 3: 활동 유형 매칭 (각 15점)
    if wantActivityTypes != null AND activityTypes != null:
        for each type in wantActivityTypes:
            if activityTypes.contains(type):
                score += 15

    // Step 4: 목적 매칭 (각 15점)
    if wantPurposes != null AND purposes != null:
        for each purpose in wantPurposes:
            if purposes.contains(purpose):
                score += 15

    return score
```

### 📍 구현 위치

- **파일**: `app/src/main/java/com/example/clubmanagement/models/Club.java`
- **메서드**: `calculateRecommendScore()` (라인 323)

### 🎯 실행 예시

#### 예시 1: 완벽한 매칭 (110점)

```
사용자 선택:
✅ 기독교 동아리
✅ 활기찬 분위기
✅ 봉사 활동
✅ 운동 활동
✅ 진로 목적
✅ 학술 목적

동아리 정보:
✅ 기독교: true
✅ 분위기: "lively"
✅ 활동: ["volunteer", "sports"]
✅ 목적: ["career", "academic"]

계산 과정:
- 기독교 매칭: +30점
- 분위기 매칭: +20점
- 봉사 매칭: +15점
- 운동 매칭: +15점
- 진로 매칭: +15점
- 학술 매칭: +15점
────────────────────
총점: 110점 (🌟🌟🌟 최고 추천)
```

#### 예시 2: 부분 매칭 (65점)

```
사용자 선택:
✅ 기독교 동아리
✅ 활기찬 분위기
✅ 봉사 활동
✅ 진로 목적
✅ 학술 목적

동아리 정보:
❌ 기독교: false
✅ 분위기: "lively"
✅ 활동: ["volunteer"]
✅ 목적: ["career", "academic"]

계산 과정:
- 기독교 매칭: +0점
- 분위기 매칭: +20점
- 봉사 매칭: +15점
- 진로 매칭: +15점
- 학술 매칭: +15점
────────────────────
총점: 65점 (🌟🌟 강력 추천)
```

### 📈 시간 복잡도

- **최선/평균/최악**: O(n + m)
  - n: 선택한 활동 유형 개수 (최대 2개)
  - m: 선택한 목적 개수 (최대 2개)
- **실제**: O(1) (최대 반복 횟수가 상수)

---

## 알고리즘 2: 버블 정렬 (추천 점수 기준)

### 📌 개요

추천 점수가 높은 동아리부터 보여주기 위해 **버블 정렬**로 내림차순 정렬합니다.

### 🔍 알고리즘 설명

```
1. 외부 반복문: i = 0 to n-2
2. 내부 반복문: j = 0 to n-i-2
3. 비교: scores[j] < scores[j+1]?
4. TRUE면 교환:
   - 점수 교환
   - 동아리도 함께 교환
```

### 💻 의사코드

```java
function sortByScore(clubs, scores):
    n = scores.size()

    for i = 0 to n-2:
        for j = 0 to n-i-2:
            if scores[j] < scores[j+1]:  // 내림차순
                // 점수 교환
                temp = scores[j]
                scores[j] = scores[j+1]
                scores[j+1] = temp

                // 동아리도 함께 교환
                tempClub = clubs[j]
                clubs[j] = clubs[j+1]
                clubs[j+1] = tempClub
```

### 📍 구현 위치

- **파일**: `app/src/main/java/com/example/clubmanagement/activities/ClubRecommendActivity.java`
- **메서드**: `sortByScore()` (라인 248)

### 📈 시간 복잡도

- **최악의 경우**: O(n²)
- **평균**: O(n²)
- **최선**: O(n²)

### 💡 알고리즘 선택 이유

- 동아리 개수가 많지 않음 (일반적으로 10~50개)
- 구현이 간단하고 직관적
- 작은 데이터셋에서는 O(n²)도 충분히 빠름

---

## 알고리즘 3: 상대 시간 표시

### 📌 개요

공지사항 작성 시간을 사용자 친화적으로 표시 ("방금 전", "3분 전", "2일 전")

### 🔍 알고리즘 설명

```
1. 현재 시간과 대상 시간의 차이 계산 (밀리초)
2. 밀리초를 초/분/시/일/주/개월/년으로 변환
3. 조건에 따라 적절한 문자열 반환
```

### 💻 의사코드

```java
function getTimeAgo(date):
    diff = System.currentTimeMillis() - date.getTime()

    seconds = diff / 1000
    minutes = seconds / 60
    hours = minutes / 60
    days = hours / 24
    weeks = days / 7
    months = days / 30
    years = days / 365

    if seconds < 60:
        return "방금 전"
    else if minutes < 60:
        return minutes + "분 전"
    else if hours < 24:
        return hours + "시간 전"
    else if days < 7:
        return days + "일 전"
    else if days < 30:
        return weeks + "주 전"
    else if days < 365:
        return months + "개월 전"
    else:
        return years + "년 전"
```

### 📍 구현 위치

- **파일**: `app/src/main/java/com/example/clubmanagement/utils/DateHelper.java`
- **메서드**: `getTimeAgo()` (라인 154)

### 🎯 실행 예시

| 경과 시간 | 출력 |
|----------|------|
| 30초 | "방금 전" |
| 5분 | "5분 전" |
| 3시간 | "3시간 전" |
| 2일 | "2일 전" |
| 10일 | "1주 전" |
| 45일 | "1개월 전" |
| 400일 | "1년 전" |

### 📈 시간 복잡도

- **O(1)** - 상수 시간

---

## 알고리즘 4: 스마트 날짜 표시

### 📌 개요

날짜를 컨텍스트에 맞게 표시 (오늘 → 시간만, 올해 → 월/일, 과거 → 전체 날짜)

### 🔍 알고리즘 설명

```
1. 현재 날짜와 대상 날짜 비교
2. 같은 날이면 → 시간만 표시 (HH:mm)
3. 같은 해면 → 월/일 표시 (MM.dd)
4. 다른 해면 → 전체 날짜 표시 (yyyy.MM.dd)
```

### 💻 의사코드

```java
function getSmartDate(date):
    now = Calendar.getInstance()
    target = Calendar.getInstance()
    target.setTime(date)

    if isSameDay(now, target):
        return formatTime(date)  // "14:30"
    else if now.year == target.year:
        return formatMonthDay(date)  // "12.25"
    else:
        return formatDate(date)  // "2024.12.25"
```

### 📍 구현 위치

- **파일**: `app/src/main/java/com/example/clubmanagement/utils/DateHelper.java`
- **메서드**: `getSmartDate()` (라인 193)

### 🎯 실행 예시

| 날짜 | 현재 날짜 | 출력 |
|------|----------|------|
| 2025-12-02 14:30 | 2025-12-02 | "14:30" |
| 2025-11-25 10:00 | 2025-12-02 | "11.25" |
| 2024-06-15 09:00 | 2025-12-02 | "2024.06.15" |

### 📈 시간 복잡도

- **O(1)** - 상수 시간

---

## 알고리즘 5: 중앙동아리 자격 계산

### 📌 개요

동아리 설립일로부터 경과한 일수를 계산하고, 중앙동아리 신청 자격 여부를 판단합니다.

### 📊 자격 조건

| 조건 | 신규 등록 | 유지 |
|------|----------|------|
| **설립 기간** | 180일 (6개월) 이상 | 제한 없음 |
| **회원 수** | 20명 이상 | 15명 이상 |

### 🔍 알고리즘 설명

#### 1. 설립 후 경과 일수 계산

```
1. 설립일이 null이면 → 0 반환
2. 현재 시간(밀리초) - 설립 시간(밀리초)
3. 밀리초를 일수로 변환 (÷ 1000 ÷ 60 ÷ 60 ÷ 24)
4. 경과 일수 반환
```

#### 2. 자격 충족 여부 판단

```
1. 경과 일수 계산
2. 조건 1: 경과 일수 >= 180?
3. 조건 2: 회원 수 >= 20?
4. 조건 1 AND 조건 2 → 자격 충족
```

### 💻 의사코드

```java
// 경과 일수 계산
function getDaysSinceFounding(foundedAt):
    if foundedAt == null:
        return 0

    foundedMillis = foundedAt.getTime()
    currentMillis = System.currentTimeMillis()
    diffMillis = currentMillis - foundedMillis

    return diffMillis / (1000 * 60 * 60 * 24)

// 자격 충족 여부
function canApplyForCentral(foundedAt, memberCount):
    daysSinceFounding = getDaysSinceFounding(foundedAt)

    periodEligible = daysSinceFounding >= 180
    memberEligible = memberCount >= 20

    return periodEligible AND memberEligible

// 진행률 계산
function getFoundingProgressPercent(foundedAt):
    daysSinceFounding = getDaysSinceFounding(foundedAt)

    if daysSinceFounding >= 180:
        return 100

    ratio = daysSinceFounding / 180.0
    return (int)(ratio * 100)
```

### 📍 구현 위치

- **파일**: `app/src/main/java/com/example/clubmanagement/models/Club.java`
- **메서드**:
  - `getDaysSinceFounding()` (라인 248)
  - `canApplyForCentralByDate()` (라인 257)
  - `getFoundingProgressPercent()` (라인 280)

### 🎯 실행 예시

#### 예시 1: 자격 충족

```
설립일: 2024-06-01
현재 날짜: 2025-12-02
경과 일수: 549일 ✅ (>= 180)
회원 수: 25명 ✅ (>= 20)
────────────────────
결과: 신청 가능 🎉
진행률: 100%
```

#### 예시 2: 기간 미달

```
설립일: 2025-10-01
현재 날짜: 2025-12-02
경과 일수: 62일 ❌ (< 180)
회원 수: 25명 ✅ (>= 20)
────────────────────
결과: 신청 불가
사유: 설립 후 118일 더 경과해야 합니다
진행률: 34%
```

### 📈 시간 복잡도

- **O(1)** - 상수 시간

---

## 알고리즘 6: 가입 신청 기간 체크

### 📌 개요

현재 시간이 가입 신청 기간 내인지 확인하고, 마감일까지 남은 일수를 계산합니다.

### 🔍 알고리즘 설명

#### 1. 가입 신청 가능 여부

```
1. 가입 신청이 닫혀있으면 → false
2. 마감일이 설정되어 있으면:
   - 현재 시간 < 마감 시간 → true
   - 그렇지 않으면 → false
3. 마감일이 없으면 → true (무기한)
```

#### 2. 마감일까지 남은 일수

```
1. 마감일이 null이면 → -1 (무기한)
2. 현재 시간 >= 마감 시간이면 → 0 (마감됨)
3. 차이 계산: (마감 시간 - 현재 시간) / (1000*60*60*24)
4. 남은 일수 반환
```

### 💻 의사코드

```java
// 가입 신청 가능 여부
function canApplyNow(applicationOpen, applicationEndDate):
    // 가입 신청이 닫혀있으면
    if NOT applicationOpen:
        return false

    // 마감일이 설정되어 있으면
    if applicationEndDate != null:
        currentTime = System.currentTimeMillis()
        endTime = applicationEndDate.getTime()
        return currentTime < endTime

    // 마감일 없으면 언제나 가능
    return true

// 마감일까지 남은 일수
function getDaysUntilApplicationEnd(applicationEndDate):
    if applicationEndDate == null:
        return -1  // 무기한

    currentTime = System.currentTimeMillis()
    endTime = applicationEndDate.getTime()

    if currentTime >= endTime:
        return 0  // 이미 마감

    diff = endTime - currentTime
    return diff / (1000 * 60 * 60 * 24)
```

### 📍 구현 위치

- **파일**: `app/src/main/java/com/example/clubmanagement/models/Club.java`
- **메서드**:
  - `canApplyNow()` (라인 439)
  - `getDaysUntilApplicationEnd()` (라인 452)

### 🎯 실행 예시

| 가입 신청 상태 | 마감일 | 현재 날짜 | 결과 | 남은 일수 |
|---------------|--------|----------|------|----------|
| ✅ 열림 | 2025-12-31 | 2025-12-02 | ✅ 가입 가능 | 29일 |
| ✅ 열림 | 2025-11-30 | 2025-12-02 | ❌ 기간 만료 | 0일 |
| ✅ 열림 | null | 2025-12-02 | ✅ 가입 가능 | -1 (무기한) |
| ❌ 닫힌 | 2025-12-31 | 2025-12-02 | ❌ 가입 불가 | - |

### 📈 시간 복잡도

- **O(1)** - 상수 시간

---

## 알고리즘 7: 예산 잔액 계산 및 배치 트랜잭션

### 📌 개요

수입/지출 발생 시 잔액을 계산하고, **원자성 보장을 위해 배치 트랜잭션**을 사용합니다.

### 🔍 알고리즘 설명

```
1. 거래 유형에 따라 새 잔액 계산
   - 수입: 현재 잔액 + 금액
   - 지출: 현재 잔액 - 금액
   - 조정: 새 잔액 (직접 입력)

2. 배치 트랜잭션 시작
   - 거래 문서 추가
   - 동아리 잔액 업데이트

3. 배치 커밋 (모두 성공 or 모두 실패)
```

### 💻 의사코드

```java
// 거래 추가
function addTransaction(transaction, newBalance):
    // 거래 ID 생성
    transactionId = generateUniqueId()
    transaction.setId(transactionId)
    transaction.setCreatedAt(Timestamp.now())
    transaction.setBalanceAfter(newBalance)

    // 배치 작업 시작 (원자성 보장)
    batch = db.batch()

    // 1. 거래 문서 추가
    transactionRef = db.collection("clubs")
                        .document(clubId)
                        .collection("budgetTransactions")
                        .document(transactionId)
    batch.set(transactionRef, transaction)

    // 2. 동아리 잔액 업데이트
    clubRef = db.collection("clubs").document(clubId)
    batch.update(clubRef, "currentBudget", newBalance)

    // 3. 배치 커밋 (모두 성공 or 모두 실패)
    batch.commit()

// 수입 추가
function addIncome(clubId, amount, currentBalance):
    newBalance = currentBalance + amount
    transaction = new Transaction("INCOME", amount)
    addTransaction(transaction, newBalance)

// 지출 추가
function addExpense(clubId, amount, currentBalance):
    newBalance = currentBalance - amount
    transaction = new Transaction("EXPENSE", amount)
    addTransaction(transaction, newBalance)
```

### 📍 구현 위치

- **파일**: `app/src/main/java/com/example/clubmanagement/utils/BudgetManager.java`
- **메서드**:
  - `addTransaction()` (라인 185)
  - `addIncome()` (라인 220)
  - `addExpense()` (라인 233)

### 🎯 원자성 보장

```
시나리오 1: 모두 성공
✅ 거래 문서 추가 성공
✅ 잔액 업데이트 성공
→ 배치 커밋 성공

시나리오 2: 부분 실패
✅ 거래 문서 추가 성공
❌ 잔액 업데이트 실패
→ 배치 롤백 (모든 작업 취소)

시나리오 3: 조기 실패
❌ 거래 문서 추가 실패
→ 배치 롤백 (잔액 업데이트 시도 안함)
```

### 📈 시간 복잡도

- **O(1)** - Firestore 배치 쓰기는 상수 시간

---

## 알고리즘 8: 생일 회원 조회 및 정렬

### 📌 개요

오늘/이번 달 생일인 회원을 조회하고, 생일 일자 기준으로 정렬합니다.

### 🔍 알고리즘 설명

#### 1. 오늘 생일인 회원 조회

```
1. 오늘 월/일 가져오기
2. Firestore 복합 쿼리 실행
   - birthMonth == 오늘 월
   - birthDay == 오늘 일
3. 결과 반환
```

#### 2. 이번 달 생일인 회원 조회 및 정렬

```
1. 현재 월 가져오기
2. Firestore 쿼리 실행
   - birthMonth == 현재 월
3. 결과를 생일 일자 기준 오름차순 정렬
4. 정렬된 결과 반환
```

### 💻 의사코드

```java
// 오늘 생일인 회원 조회
function getTodayBirthdayMembers(clubId):
    today = Calendar.getInstance()
    todayMonth = today.get(MONTH) + 1
    todayDay = today.get(DAY_OF_MONTH)

    members = db.collection("clubs")
                .document(clubId)
                .collection("members")
                .whereEqualTo("birthMonth", todayMonth)
                .whereEqualTo("birthDay", todayDay)
                .get()

    return members

// 이번 달 생일인 회원 조회 및 정렬
function getThisMonthBirthdayMembers(clubId):
    today = Calendar.getInstance()
    currentMonth = today.get(MONTH) + 1

    members = db.collection("clubs")
                .document(clubId)
                .collection("members")
                .whereEqualTo("birthMonth", currentMonth)
                .get()

    // 생일 일자 기준 오름차순 정렬
    members.sort((m1, m2) -> m1.birthDay - m2.birthDay)

    return members
```

### 📍 구현 위치

- **파일**: `app/src/main/java/com/example/clubmanagement/utils/MemberManager.java`
- **메서드**:
  - `getTodayBirthdayMembers()` (라인 285)
  - `getThisMonthBirthdayMembers()` (라인 313)

### 🎯 실행 예시

#### 오늘 생일 (12월 2일)

```
현재 날짜: 2025-12-02

조회 결과:
✅ 김철수 (1998-12-02)
✅ 박영희 (2001-12-02)
```

#### 이번 달 생일 (12월)

```
현재 날짜: 2025-12-02

조회 결과 (일자 정렬):
1. 김철수 (12월 2일)
2. 이민수 (12월 5일)
3. 박영희 (12월 15일)
4. 최지훈 (12월 25일)
```

### 📈 시간 복잡도

- **조회**: O(n) - n은 조회된 회원 수
- **정렬**: O(n log n) - Java 기본 정렬 알고리즘

---

## 📊 알고리즘 복잡도 요약

| 알고리즘 | 시간 복잡도 | 공간 복잡도 | 비고 |
|---------|------------|------------|------|
| 가중치 기반 추천 | O(1) | O(1) | 최대 반복 4회 |
| 버블 정렬 | O(n²) | O(1) | 작은 데이터셋 |
| 상대 시간 표시 | O(1) | O(1) | 조건 분기 |
| 스마트 날짜 표시 | O(1) | O(1) | 조건 분기 |
| 중앙동아리 자격 | O(1) | O(1) | 산술 연산 |
| 가입 신청 기간 | O(1) | O(1) | 조건 분기 |
| 배치 트랜잭션 | O(1) | O(1) | Firestore 쓰기 |
| 생일 회원 정렬 | O(n log n) | O(n) | Java 정렬 |

---

## 🎯 알고리즘 특징 및 장점

### 1. 가중치 기반 추천 알고리즘

**특징:**
- 다차원 매칭 (4가지 기준)
- 계층적 가중치 적용
- 확장 가능한 구조

**장점:**
- 사용자 의도를 정확하게 반영
- 추천 품질이 높음
- 가중치 조정으로 쉽게 튜닝 가능

### 2. 배치 트랜잭션

**특징:**
- 원자성 보장 (ACID)
- 여러 작업을 하나의 단위로 처리
- 데이터 일관성 유지

**장점:**
- 거래와 잔액이 항상 동기화
- 부분 실패 방지
- 데이터 무결성 보장

### 3. 날짜/시간 처리

**특징:**
- 컨텍스트 기반 표시
- 사용자 친화적 UI
- 일관된 포맷

**장점:**
- 가독성 향상
- UX 개선
- 국제화 지원 용이

---

## 🔧 개선 가능 사항

### 1. 정렬 알고리즘

**현재:** 버블 정렬 O(n²)
**개선:** 퀵 정렬 또는 Collections.sort() 사용 → O(n log n)

```java
// 개선 예시
Collections.sort(clubs, (c1, c2) -> {
    int score1 = c1.getScore();
    int score2 = c2.getScore();
    return Integer.compare(score2, score1);  // 내림차순
});
```

### 2. 추천 알고리즘

**현재:** 단순 선형 가중치
**개선:** 머신러닝 기반 추천 시스템

- 사용자 행동 데이터 학습
- 협업 필터링 적용
- TF-IDF 기반 텍스트 매칭

### 3. 캐싱

**현재:** Firestore 기본 캐싱
**개선:** 앱 레벨 캐싱 추가

```java
// 메모리 캐시 예시
private Map<String, List<Club>> clubCache = new HashMap<>();
private long cacheTimestamp = 0;
private static final long CACHE_DURATION = 5 * 60 * 1000; // 5분
```

---

## 📚 참고 자료

1. **알고리즘 이론**
   - Introduction to Algorithms (CLRS)
   - 시간 복잡도 분석

2. **Firebase 공식 문서**
   - Firestore 트랜잭션
   - 배치 쓰기

3. **디자인 패턴**
   - Strategy Pattern (알고리즘 선택)
   - Singleton Pattern (Manager 클래스)

---

## 📝 라이선스

이 문서는 졸업작품 제출용으로 작성되었습니다.

**작성자**: [학번] [이름]
**지도교수**: [교수님 성함]
**제출일**: 2025년 12월

---

**End of Document**
